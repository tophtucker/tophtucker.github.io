<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Toph Tucker</title>

<style>

body {
  font-size: 14px;
  max-width: 20em;
  margin: 1em auto;
}
h1, h2, h3 {
  font-weight: normal;
}


.underlying {
  opacity: 0;
  pointer-events: none;
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
}

.overlay span {
  position: absolute;
}

svg {
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

@media screen and (min-width: 320px) {
  body {
    font-size: calc(14px + 8 * ((100vw - 320px) / 960));
  }
}
@media screen and (min-width: 1280px) {
  body {
    font-size: 22px;
  }
}

</style>

<body>
  
  <div class="underlying"></div>

  <div class="overlay"></div>

  <svg></svg>

  <template id="home">
    <h1>Toph Tucker</h1>
    <p>
      Web programmer at Kensho, formerly Businessweek. 
      <a href="https://twitter.com/tophtucker/">Twitter</a>, 
      <a href="https://github.com/tophtucker">GitHub</a>, 
      <a href="http://bl.ocks.org/tophtucker">bl.ocks</a>,
      <a href="https://medium.com/@tophtucker/">Medium</a>,
      tophtucker@gmail.com
    </p>
  </template>

</body>

<script src="d3.v4.js"></script>
<script src='improvedNoise.js'></script>
<script>

var noiseScale = 300,
    noiseStrength = 10,
    noise = noiser(4,.8);

var mouse = [-100,-100];
d3.select('html').on('mousemove.forceMouse', function() {
  mouse = d3.mouse(this);
})

var projects = [
  {
    title: 'The Trading Game',
    slug: 'the-trading-game',
    url: 'http://www.bloomberg.com/features/2015-stock-chart-trading-game/',
    date: 'October 2015',
    byline: '',
    description: 'This little mobile-first chart game abuses the very chic aesthetic of the very serious Bloomberg Terminal to (1) waste time and (2) confront the vanity of expecting market-beating returns by assuming the future will look like the past. So the game has an unstated thesis, which it argues just by showing you your results, like what Ian Bogost calls “procedural rhetoric”: the ability of a game, or any system of interaction, to make a point.'
  },

  {
    title: 'How ETFs Work',
    slug: 'how-etfs-work',
    url: 'http://www.bloomberg.com/features/2016-etf-files/toy/',
    date: 'March 2016',
    byline: '',
    description: 'What’s an exchange-traded fund (ETF), and how do people make money on it? For the big banks, the answer turns out to be, in a mathematically precise way: you get paid to balance a big see-saw of weights of various sizes, rolling up and down as prices move. That seems to make it easier to understand. A small child could do it. People go, “That’s it??”, and that feels like a triumph. People intuitively understand complex systems all around them all the time! You just need to code up a rigorous graphical-geometrical-mechanical metaphor.'
  },

  {
    title: 'What Is Code'
  },

  {
    title: 'MTA spaghetti'
  },

  {
    title: 'Romeo & Juliet'
  },

  {
    title: 'Experiments in typography',
    slug: 'experiments-in-typography',
    url: 'http://www.tophtucker.com/type/',
    date: 'April 2015',
    byline: '',
    description: '“Plain text” is sometimes treated (especially by programmers!) like a solved problem. You have these letters, proportionally sized and spaced and kerned, and one comes after the next, and they wrap onto lines in some grid. If you want to get fancy maybe you have ligatures. Watching the designers at Businessweek – who can, like, do valley girl intonation in type — disabused me of that worldview. Lots of people are trying great things and of course it’s hard to compete with convention on a meaningful scale here, but I’ll try — nothing fancy with the fonts here per se, just some more dynamic setting.'
  },

  {
    title: 'The Bowdoin Orient'
  }
];

var letterSim = d3.forceSimulation()
  .alphaDecay(0)
  .force("x", d3.forceX(function(d) { return d.x1; }).strength(.05))
  .force("y", d3.forceY(function(d) { return d.y1; }).strength(.05))
  // .force("mouse", forceMouse())
  .force("motion", forceMotion())
  .force("noise", forceNoise());

handleNav();
window.addEventListener("hashchange", handleNav, false);

function split(container) {
  if(!container.childNodes.length) {
    var letters = container.textContent.split('');
    return letters.map(function(d) { return '<span class="ltr">' + d + '</span>'; }).join('');
  } else {
    var html = '';
    for(var i = 0; i < container.childNodes.length; i++) {
      html += split(container.childNodes[i]);
    }
    container.innerHTML = html;
    return container.outerHTML;
  }
}

function computePositions(container) {

  // compute positions and styles of letters as rendered
  d3.select(container).selectAll('span.ltr')
    .datum(function(d,i) {
      var styles = window.getComputedStyle(this);
      return {
        letter: this.textContent,
        index: i,
        char: this.textContent.charCodeAt(0),
        x1: this.offsetLeft,
        y1: this.offsetTop,
        fontSize: styles['font-size'],
        fontWeight: styles['font-weight'],
        fontStyle: styles['font-style'],
        color: styles['color']
      }
    });

  // attach links to children spans 
  // (since they'll be disassociated from the dom tree)
  d3.select(container).selectAll('a').each(function() {
    var href = this.attributes.href.value;
    d3.select(this).selectAll('span.ltr')
      .each(function(d) {
        d.href = href;
      })
  });

  var data = d3.select(container).selectAll('span.ltr').data();

  // for every letter, find it's the nth letter of its kind
  var nester = d3.nest().key(function(d) { return d.char; });
  var data = d3.merge(nester.entries(data).map(function(d) { 
    return d.values.map(function(dd, ii) { 
      dd.charI = ii;
      dd.key = d.key + '-' + ii;
      return dd;
    }); 
  })).sort(function(a,b) {
    return a.index - b.index;
  });

  return data;
}

function render(data) {

  var letters = d3.select('.overlay')
    .selectAll('span')
    .data(data, function(d) { return d.key; })
    .each(function(d) {
      if(!d.x) d.x = parseFloat(d3.select(this).style('left'));
      if(!d.y) d.y = parseFloat(d3.select(this).style('top'));
    });

  letters.exit()
    .each(function(d) {
      var r = Math.sqrt(Math.pow(innerWidth,2) + Math.pow(innerHeight,2)) / 2;
      var theta = Math.random() * 2 * Math.PI;
      d.x1 = (innerWidth/2 + r * Math.cos(theta));
      d.y1 = (innerHeight/2 + r * Math.sin(theta));
    })
    .transition()
    .duration(1000)
    .style('left', function(d) { return d.x1 + 'px'; })
    .style('top', function(d) { return d.y1 + 'px'; })
    .remove();

  letters = letters.enter().append('span')
    .text(function(d) { return d.letter; })
    .text(function(d) { return d.letter; })
    .each(function(d) {
      var r = Math.sqrt(Math.pow(innerWidth,2) + Math.pow(innerHeight,2)) / 2;
      var theta = Math.random() * 2 * Math.PI;
      d.x = (innerWidth/2 + r * Math.cos(theta));
      d.y = (innerHeight/2 + r * Math.sin(theta));
    })
    .style('left', function(d) { return d.x0 + 'px'; })
    .style('top', function(d) { return d.y0 + 'px'; })
  .merge(letters)
    .style('cursor', function(d) { return d.href ? 'pointer' : 'default'; })
    .on('click', function(d) {
      if(d.href) window.location = d.href;
    });

  letters.transition()
    .duration(1000)
    .style('font-size', function(d) { return d.fontSize; })
    .style('font-weight', function(d) { return d.fontWeight; })
    .style('font-style', function(d) { return d.fontStyle; })
    .style('color', function(d) { return d.color; })

  letterSim
    .nodes(letters.data())
    .on('tick', function() {
      letters
        .style('left', function(d) { return d.x + 'px'; })
        .style('top', function(d) { return d.y + 'px'; });
    });

}


function renderHome(container) {
  container.html(document.querySelector('#home').innerHTML);
  container.selectAll('h2.project')
    .data(projects)
    .enter()
    .append('h2')
    .classed('project', true)
    .append('a')
    .attr('href', function(d) { return '#' + d.slug; })
    .text(function(d) { return d.title; });
}

function renderProject(container, slug) {
  var project = projects.filter(function(d) { return d.slug === slug; })[0];

  container.html('');
  container.append('h1')
    .append('a')
    .attr('href', '#')
    .text('Toph Tucker');

  container.append('h2').text(project.title);
  container.append('p').html(project.date);
  container.append('p').html(project.byline);
  container.append('a').attr('href', project.url).text(project.url);
  container.append('p').html(project.description);
}

function handleNav() {
  if(window.location.hash === '' || window.location.hash === '#') {
    renderHome(d3.select('.underlying'));
  } else {
    renderProject(d3.select('.underlying'), window.location.hash.split('#')[1]);
  }

  d3.select('.underlying')
    .each(function() {
      split(this);
      render(computePositions(this));
    });
}

function forceMouse() {

  var nodes;

  function force(alpha) {
    if(innerWidth < 500) return;
    for (var i = 0, n = nodes.length, node, k = alpha; i < n; ++i) {
      node = nodes[i];
      var dist = distance(mouse, [node.x,node.y]);
      node.vx += (mouse[0] - node.x) * 1 / dist;
      node.vy += (mouse[1] - node.y) * 1 / dist;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  }

  return force;

}

function forceNoise() {

  var nodes;

  function force(alpha) {
    if(innerWidth < 500) return;
    for (var i = 0, n = nodes.length, node, k = alpha; i < n; ++i) {
      node = nodes[i];

      var dist = distance(mouse, [node.x,node.y]);
      var angle = noise(node.x / noiseScale, node.y / noiseScale) * noiseStrength;
      var driftX =  Math.cos(angle) * .00001 * Math.pow(dist,2);
      var driftY = -Math.sin(angle) * .00001 * Math.pow(dist,2);

      node.vx += driftX;
      node.vy += driftY;

    }
  }

  force.initialize = function(_) {
    nodes = _;
  }

  return force;

}

function forceMotion() {

  var nodes,
      rotation,
      acceleration;

  window.addEventListener('devicemotion', handleMotion);
  window.addEventListener('deviceorientation', handleOrientation);

  var gammaScale = d3.scaleLinear()
    .domain([-Math.PI/2, Math.PI/2])
    .range([0,innerWidth])
    .clamp(true);

  var betaScale = d3.scaleLinear()
    .domain([-Math.PI/2, Math.PI/2])
    .range([0,innerHeight])
    .clamp(true);

  function force(alpha) {
    if(acceleration === undefined || rotation === undefined) return;

    for (var i = 0, n = nodes.length, node, k = alpha; i < n; ++i) {
      node = nodes[i];

      var dist = distance([node.x,node.y], [gammaScale(rotation.gamma), betaScale(rotation.beta)]);

      node.vx += acceleration.x * 1000 / dist;
      node.vy -= acceleration.y * 1000 / dist;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  }

  function handleOrientation(e) {
    if(e.gamma === null || e.beta === null || e.alpha === null) return;
    rotation = {
      gamma: e.gamma || 0,
      beta: e.beta || 0,
      alpha: e.alpha || 0
    }
  }

  function handleMotion(e) {
    if(e.acceleration.x === null || e.acceleration.y === null || e.acceleration.z === null) return;
    acceleration = {
      x: e.acceleration.x,
      y: e.acceleration.y,
      z: e.acceleration.z
    };
  }

  return force;

}

function forceTorus() {
  var nodes;
  function force(alpha) {
    for (var i = 0, n = nodes.length, node, k = alpha; i < n; ++i) {
      node = nodes[i];
      if(node.x > innerWidth) node.x = 0;
      if(node.x < 0) node.x = innerWidth;
      if(node.y > innerHeight) node.y = 0;
      if(node.y < 0) node.y = innerHeight;
    }
  }
  force.initialize = function(_) {
    nodes = _;
  }
  return force;
}

function forceMortality() {
  var nodes;
  function force(alpha) {
    for (var i = 0, n = nodes.length, node, k = alpha; i < n; ++i) {
      node = nodes[i];
      // node.r *= .99;
      if(Math.random() > 0.99) {
        node.x = Math.random() * innerWidth;
        node.y = Math.random() * innerHeight;
      }
    }
  }
  force.initialize = function(_) {
    nodes = _;
  }
  return force;
}

function distance(a,b) {
  var dx = b[0] - a[0];
  var dy = b[1] - a[1];
  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
}

////////////////////////////////
///// BACKGROUND PARTICLES /////
////////////////////////////////

var particleSim = d3.forceSimulation()
  .alphaDecay(0)
  .force("motion", forceMotion())
  .force("noise", forceNoise())
  .force("torus", forceTorus())
  .force("mortality", forceMortality());

function renderParticles() {

  var particles = d3.range(500).map(function(d) {
    return {
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      vx: 0,
      vy: 0,
      r: 1,
      color: '#999'
    }
  });

  var particle = d3.select('svg').selectAll('circle')
    .data(particles)
    .enter()
    .append('circle')
    .style('fill', function(d) { return d.color; })
    .attr('r', function(d) { return d.r; });

  particleSim
    .nodes(particles)
    .on('tick', function() {
      particle
        .attr('cx', function(d) { return d.x; })
        .attr('cy', function(d) { return d.y; })
        .attr('r', function(d) { return d.r; });
    });
}

renderParticles();

</script>

</html>